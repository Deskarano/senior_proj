KCPSM6 Assembler log file for program 'C:\Users\grego\Projects\fpga\picoblaze_test\picoblaze_test.srcs\programs\stack_prog\stack_prog.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 20 Mar 2019
Assembly timestamp: 14:50:08

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 0B6 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 183
Memory locations available: 3913


Assembly listing

 Addr Code                          Instruction

 000                                CONSTANT out_uart_data, 00000001'b
 000                                CONSTANT out_mem_addr, 00000010'b
 000                                CONSTANT out_mem_data_p0, 00000011'b
 000                                CONSTANT out_mem_data_p1, 00001011'b
 000                                CONSTANT in_uart_data, 01
 000                                CONSTANT in_uart_status, 02
 000                                CONSTANT in_mem_data, 03
 000                                CONSTANT tx_data_present, 00100000'b
 000                                CONSTANT tx_buffer_half, 00010000'b
 000                                CONSTANT tx_buffer_full, 00001000'b
 000                                CONSTANT rx_data_present, 00000100'b
 000                                CONSTANT rx_buffer_half, 00000010'b
 000                                CONSTANT rx_buffer_full, 00000001'b
 000                                ; Register mapping
 000                                ; s0 - stack pointer (points to next empty)
 000                                ; s1 - stack reg
 000                                ; s2 - uart reg
 000                                ; s3 - mem reg 1
 000                                ; s4 - mem reg 2
 000                                ; s5 - mem reg 3 (parity)
 000                                ; s6 -> sD - miscellaneous
 000                                ; sE - memory iterator (for dump_ram)
 000                                ; sF - write address
 000                          init: 
 000  01000                         LOAD s0, 00
 001  01100                         LOAD s1, 00
 002  01200                         LOAD s2, 00
 003  01300                         LOAD s3, 00
 004  01400                         LOAD s4, 00
 005  01500                         LOAD s5, 00
 006  01600                         LOAD s6, 00
 007  01E00                         LOAD sE, 00
 008  01F00                         LOAD sF, 00
 009                          main: 
 009                                ; first push the two address bytes to the stack
 009  001F0                         LOAD s1, sF
 00A  20089                         CALL 089[stack_push]
 00B  01100                         LOAD s1, 00
 00C  20089                         CALL 089[stack_push]
 00D                                ; wait for 3 bytes from uart
 00D  20079                         CALL 079[uart_recv]
 00E  20080                         CALL 080[uart_send]
 00F  01220                         LOAD s2, 20
 010  20080                         CALL 080[uart_send]
 011  20093                         CALL 093[print_binary_byte]
 012  01220                         LOAD s2, 20
 013  20080                         CALL 080[uart_send]
 014  20082                         CALL 082[uart_empty_tx_buf]
 015  20079                         CALL 079[uart_recv]
 016  20080                         CALL 080[uart_send]
 017  01220                         LOAD s2, 20
 018  20080                         CALL 080[uart_send]
 019  20093                         CALL 093[print_binary_byte]
 01A  01220                         LOAD s2, 20
 01B  20080                         CALL 080[uart_send]
 01C  20082                         CALL 082[uart_empty_tx_buf]
 01D  20079                         CALL 079[uart_recv]
 01E  20080                         CALL 080[uart_send]
 01F  01220                         LOAD s2, 20
 020  20080                         CALL 080[uart_send]
 021  20093                         CALL 093[print_binary_byte]
 022  01220                         LOAD s2, 20
 023  20080                         CALL 080[uart_send]
 024  20082                         CALL 082[uart_empty_tx_buf]
 025                                ; write to memory and notify user that write happened
 025  20062                         CALL 062[write_to_mem]
 026  01221                         LOAD s2, 21
 027  20080                         CALL 080[uart_send]
 028                                ; increment memory addr and dump out the RAM
 028  11F01                         ADD sF, 01
 029  2002B                         CALL 02B[dump_ram]
 02A  22009                         JUMP 009[main]
 02B                      dump_ram: 
 02B  01E00                         LOAD sE, 00
 02C                 dump_ram_loop: 
 02C  20090                         CALL 090[print_nl]
 02D                                ; print out the hex address
 02D  001E0                         LOAD s1, sE
 02E  20089                         CALL 089[stack_push]
 02F  200A1                         CALL 0A1[print_hex_byte]
 030                                ; print a colon and a spacce
 030  0123A                         LOAD s2, 3A
 031  20080                         CALL 080[uart_send]
 032  01220                         LOAD s2, 20
 033  20080                         CALL 080[uart_send]
 034  20082                         CALL 082[uart_empty_tx_buf]
 035                                ; load another address byte and read
 035  01100                         LOAD s1, 00
 036  20089                         CALL 089[stack_push]
 037  20054                         CALL 054[read_from_mem]
 038                                ; pop results from stack and send them (ignore parity for now)
 038  20093                         CALL 093[print_binary_byte]
 039  20086                         CALL 086[stack_pop]
 03A  00510                         LOAD s5, s1
 03B  01220                         LOAD s2, 20
 03C  20080                         CALL 080[uart_send]
 03D  20082                         CALL 082[uart_empty_tx_buf]
 03E  20093                         CALL 093[print_binary_byte]
 03F  20086                         CALL 086[stack_pop]
 040  00410                         LOAD s4, s1
 041  01220                         LOAD s2, 20
 042  20080                         CALL 080[uart_send]
 043  20082                         CALL 082[uart_empty_tx_buf]
 044  20093                         CALL 093[print_binary_byte]
 045  20086                         CALL 086[stack_pop]
 046  00310                         LOAD s3, s1
 047  01220                         LOAD s2, 20
 048  20080                         CALL 080[uart_send]
 049  20082                         CALL 082[uart_empty_tx_buf]
 04A                                ; output a space
 04A  01220                         LOAD s2, 20
 04B  20080                         CALL 080[uart_send]
 04C  2D401                         OUTPUT s4, 01[out_uart_data]
 04D  2D301                         OUTPUT s3, 01[out_uart_data]
 04E                                ; empty the buffer
 04E  20082                         CALL 082[uart_empty_tx_buf]
 04F                                ; increment read address and loop
 04F  11E01                         ADD sE, 01
 050  1CEF0                         COMPARE sE, sF
 051  3A02C                         JUMP C, 02C[dump_ram_loop]
 052  20090                         CALL 090[print_nl]
 053  25000                         RETURN 
 054                 read_from_mem: 
 054                                ; stack needs to look like this and returns this
 054                                ;
 054                                ;                                       [parity]
 054                                ; [addr 1]   [data 1]
 054                                ;_______[addr 0]______    ______[data 0]______
 054                                ; pop off the addr bytes
 054  20086                         CALL 086[stack_pop]
 055  00410                         LOAD s4, s1
 056  20086                         CALL 086[stack_pop]
 057  00310                         LOAD s3, s1
 058                                ; write them to interface
 058  2D302                         OUTPUT s3, 02[out_mem_addr]
 059  2D402                         OUTPUT s4, 02[out_mem_addr]
 05A                                ; waste a cycle for the read to r
 05A  11300                         ADD s3, 00
 05B  09103                         INPUT s1, 03[in_mem_data]
 05C  20089                         CALL 089[stack_push]
 05D  09103                         INPUT s1, 03[in_mem_data]
 05E  20089                         CALL 089[stack_push]
 05F  09103                         INPUT s1, 03[in_mem_data]
 060  20089                         CALL 089[stack_push]
 061  25000                         RETURN 
 062                  write_to_mem: 
 062                                ; stack needs to look like this
 062                                ;
 062                                ; [parity]
 062                                ;  [data 1]
 062                                ;  [data 0]
 062                                ;  [addr 1]
 062                                ; ______[addr 0]_______
 062                                ; first pop off the data bytes
 062  20086                         CALL 086[stack_pop]
 063  00510                         LOAD s5, s1
 064  20086                         CALL 086[stack_pop]
 065  00410                         LOAD s4, s1
 066  20086                         CALL 086[stack_pop]
 067  00310                         LOAD s3, s1
 068                                ; output byte depending on parity
 068  0D501                         TEST s5, 01[00000001'b]
 069  3606C                         JUMP NZ, 06C[write_to_mem_d1_p1]
 06A  2D303                         OUTPUT s3, 03[out_mem_data_p0]
 06B  2206D                         JUMP 06D[write_to_mem_d2]
 06C            write_to_mem_d1_p1: 
 06C  2D30B                         OUTPUT s3, 0B[out_mem_data_p1]
 06D               write_to_mem_d2: 
 06D  0D502                         TEST s5, 02[00000010'b]
 06E  36071                         JUMP NZ, 071[write_to_mem_d2_p1]
 06F  2D403                         OUTPUT s4, 03[out_mem_data_p0]
 070  22072                         JUMP 072[write_to_mem_addr]
 071            write_to_mem_d2_p1: 
 071  2D40B                         OUTPUT s4, 0B[out_mem_data_p1]
 072             write_to_mem_addr: 
 072                                ; then pop off the addr bytes
 072  20086                         CALL 086[stack_pop]
 073  00410                         LOAD s4, s1
 074  20086                         CALL 086[stack_pop]
 075  00310                         LOAD s3, s1
 076                                ; write those as well
 076  2D302                         OUTPUT s3, 02[out_mem_addr]
 077  2D402                         OUTPUT s4, 02[out_mem_addr]
 078  25000                         RETURN 
 079                     uart_recv: 
 079                                ; wait for a byte to be present
 079  09202                         INPUT s2, 02[in_uart_status]
 07A  03204                         AND s2, 04[rx_data_present]
 07B  32079                         JUMP Z, 079[uart_recv]
 07C                                ; retrieve the byte and push it to the stack
 07C  09201                         INPUT s2, 01[in_uart_data]
 07D  00120                         LOAD s1, s2
 07E  20089                         CALL 089[stack_push]
 07F  25000                         RETURN 
 080                     uart_send: 
 080  2D201                         OUTPUT s2, 01[out_uart_data]
 081  25000                         RETURN 
 082             uart_empty_tx_buf: 
 082  09202                         INPUT s2, 02[in_uart_status]
 083  03220                         AND s2, 20[tx_data_present]
 084  36082                         JUMP NZ, 082[uart_empty_tx_buf]
 085  25000                         RETURN 
 086                     stack_pop: 
 086  19001                         SUB s0, 01
 087  0A100                         FETCH s1, (s0)
 088  25000                         RETURN 
 089                    stack_push: 
 089  2E100                         STORE s1, (s0)
 08A  11001                         ADD s0, 01
 08B  25000                         RETURN 
 08C                    stack_peek: 
 08C  19001                         SUB s0, 01
 08D  0A100                         FETCH s1, (s0)
 08E  11001                         ADD s0, 01
 08F  25000                         RETURN 
 090                      print_nl: 
 090  2B0A1                         OUTPUTK 0A, 1[out_uart_data]
 091  2B0D1                         OUTPUTK 0D, 1[out_uart_data]
 092  25000                         RETURN 
 093             print_binary_byte: 
 093                                ; stack is like this
 093                                ;
 093                                ; _____[byte ]______
 093                                ; first write the 0b prefix
 093                                STRING bin_prefix$, "0b"
 093  2B301                         OUTPUTK 30[bin_prefix$:"0"], 1[out_uart_data]
 094  2B621                         OUTPUTK 62[bin_prefix$:"b"], 1[out_uart_data]
 095                                ; set up the print
 095  01600                         LOAD s6, 00
 096  2008C                         CALL 08C[stack_peek]
 097             print_binary_loop: 
 097  1D608                         COMPARE s6, 08
 098  3D000                         RETURN NC
 099  0D180                         TEST s1, 80[10000000'b]
 09A  3609D                         JUMP NZ, 09D[print_binary_1]
 09B  2B301                         OUTPUTK 30, 1[out_uart_data]
 09C  2209E                         JUMP 09E[print_binary_loop_end]
 09D                print_binary_1: 
 09D  2B311                         OUTPUTK 31, 1[out_uart_data]
 09E         print_binary_loop_end: 
 09E  11601                         ADD s6, 01
 09F  14102                         RL s1
 0A0  22097                         JUMP 097[print_binary_loop]
 0A1                print_hex_byte: 
 0A1                                ; stack is like this
 0A1                                ;
 0A1                                ; ______[byte]______
 0A1                                ; first write the 0x prefix
 0A1                                STRING hex_prefix$, "0x"
 0A1  2B301                         OUTPUTK 30[hex_prefix$:"0"], 1[out_uart_data]
 0A2  2B781                         OUTPUTK 78[hex_prefix$:"x"], 1[out_uart_data]
 0A3                                ; peek the byte from the stack, get the upper nibble, and push it
 0A3  2008C                         CALL 08C[stack_peek]
 0A4  1410E                         SR0 s1
 0A5  1410E                         SR0 s1
 0A6  1410E                         SR0 s1
 0A7  1410E                         SR0 s1
 0A8  20089                         CALL 089[stack_push]
 0A9  200AF                         CALL 0AF[print_hex_nibble]
 0AA                                ; lower nibble
 0AA  2008C                         CALL 08C[stack_peek]
 0AB  0310F                         AND s1, 0F[00001111'b]
 0AC  20089                         CALL 089[stack_push]
 0AD  200AF                         CALL 0AF[print_hex_nibble]
 0AE  25000                         RETURN 
 0AF              print_hex_nibble: 
 0AF                                ; stack is like this
 0AF                                ;
 0AF                                ; _____[XXXXnibble]____
 0AF  20086                         CALL 086[stack_pop]
 0B0  00210                         LOAD s2, s1
 0B1  1D20A                         COMPARE s2, 0A
 0B2  3A0B4                         JUMP C, 0B4[print_hex_nibble_end]
 0B3  11207                         ADD s2, 07
 0B4          print_hex_nibble_end: 
 0B4  11230                         ADD s2, 30
 0B5  20080                         CALL 080[uart_send]
 0B6  25000                         RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\grego\Projects\fpga\picoblaze_test\picoblaze_test.srcs\programs\stack_prog\stack_prog.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   14'd         
 timestamp_minutes 50'd         
 timestamp_seconds 08'd         
 datestamp_year    19'd         
 datestamp_month   3'd          
 datestamp_day     20'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 out_uart_data     00000001'b   stack_prog.psm
 out_mem_addr      00000010'b   stack_prog.psm
 out_mem_data_p0   00000011'b   stack_prog.psm
 out_mem_data_p1   00001011'b   stack_prog.psm
 in_uart_data      01           stack_prog.psm
 in_uart_status    02           stack_prog.psm
 in_mem_data       03           stack_prog.psm
 tx_data_present   00100000'b   stack_prog.psm
 tx_buffer_half    00010000'b   stack_prog.psm
 tx_buffer_full    00001000'b   stack_prog.psm
 rx_data_present   00000100'b   stack_prog.psm
 rx_buffer_half    00000010'b   stack_prog.psm
 rx_buffer_full    00000001'b   stack_prog.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "20 Mar 2019"  
 timestamp$        "14:50:08"     
 bin_prefix$       "0b"           stack_prog.psm
 hex_prefix$       "0x"           stack_prog.psm



List of line labels

   Label                   Addr  Source PSM File

 * init                    000   stack_prog.psm
   main                    009   stack_prog.psm
   dump_ram                02B   stack_prog.psm
   dump_ram_loop           02C   stack_prog.psm
   read_from_mem           054   stack_prog.psm
   write_to_mem            062   stack_prog.psm
   write_to_mem_d1_p1      06C   stack_prog.psm
   write_to_mem_d2         06D   stack_prog.psm
   write_to_mem_d2_p1      071   stack_prog.psm
   write_to_mem_addr       072   stack_prog.psm
   uart_recv               079   stack_prog.psm
   uart_send               080   stack_prog.psm
   uart_empty_tx_buf       082   stack_prog.psm
   stack_pop               086   stack_prog.psm
   stack_push              089   stack_prog.psm
   stack_peek              08C   stack_prog.psm
   print_nl                090   stack_prog.psm
   print_binary_byte       093   stack_prog.psm
   print_binary_loop       097   stack_prog.psm
   print_binary_1          09D   stack_prog.psm
   print_binary_loop_end   09E   stack_prog.psm
   print_hex_byte          0A1   stack_prog.psm
   print_hex_nibble        0AF   stack_prog.psm
   print_hex_nibble_end    0B4   stack_prog.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             40
 STAR              -

 AND               3
 OR                -
 XOR               -

 ADD               8
 ADDCY             -
 SUB               2
 SUBCY             -

 TEST              3
 TESTCY            -
 COMPARE           3
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                1
 SR0               4
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             6
 OUTPUT           11
 OUTPUTK           8

 STORE             2
 FETCH             2

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             12
 JUMP@             -
 CALL             66
 CALL@             -
 RETURN           13
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
