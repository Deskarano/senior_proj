KCPSM6 Assembler log file for program 'C:\Users\grego\Projects\fpga\picoblaze_test\picoblaze_test.srcs\programs\uart_prog.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 13 Mar 2019
Assembly timestamp: 11:09:59

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 083 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 132
Memory locations available: 3964


Assembly listing

 Addr Code                  Instruction

 000                        CONSTANT out_uart_data, 01
 000                        CONSTANT out_mem_addr, 02
 000                        CONSTANT out_mem_data, 03
 000                        CONSTANT in_uart_data, 01
 000                        CONSTANT in_uart_status, 02
 000                        CONSTANT in_mem_data, 03
 000                        CONSTANT tx_data_present, 00100000'b
 000                        CONSTANT tx_buffer_half, 00010000'b
 000                        CONSTANT tx_buffer_full, 00001000'b
 000                        CONSTANT rx_data_present, 00000100'b
 000                        CONSTANT rx_buffer_half, 00000010'b
 000                        CONSTANT rx_buffer_full, 00000001'b
 000                        ; Register mapping
 000                        ; s0 - uart status
 000                        ; s1 - 1st value from uart
 000                        ; s2 - 2nd value from uart
 000                        ; sB - also misc characters, used for print_hex
 000                        ; sC - misc characters
 000                        ; sD - address counter (for dump_ram)
 000                        ; sE - memory command
 000                        ; sF - memory address
 000                  init: 
 000                        ; initialize address
 000  01F00                 LOAD sF, 00[00000000'b]
 001                 start: 
 001                        ; reset state
 001  01100                 LOAD s1, 00
 002  01200                 LOAD s2, 00
 003  01C00                 LOAD sC, 00
 004  01D00                 LOAD sD, 00
 005  01E00                 LOAD sE, 00
 006                 first: 
 006                        ; wait for data on the UART input
 006  09002                 INPUT s0, 02[in_uart_status]
 007  03004                 AND s0, 04[rx_data_present]
 008  32006                 JUMP Z, 006[first]
 009  09101                 INPUT s1, 01[in_uart_data]
 00A  2D101                 OUTPUT s1, 01[out_uart_data]
 00B                second: 
 00B                        ; data waiting, read it and wait for another one
 00B  09002                 INPUT s0, 02[in_uart_status]
 00C  03004                 AND s0, 04[rx_data_present]
 00D  3200B                 JUMP Z, 00B[second]
 00E  09201                 INPUT s2, 01[in_uart_data]
 00F  2D201                 OUTPUT s2, 01[out_uart_data]
 010                 write: 
 010                        ; now have two data points
 010                        ; first, write the address and data
 010  2DF02                 OUTPUT sF, 02[out_mem_addr]
 011  2D103                 OUTPUT s1, 03[out_mem_data]
 012  01C00                 LOAD sC, 00[00000000'b]
 013  2DC02                 OUTPUT sC, 02[out_mem_addr]
 014  2D203                 OUTPUT s2, 03[out_mem_data]
 015                        ; increment the next memory address
 015  11F01                 ADD sF, 01
 016                        ; send something to the user
 016  01C21                 LOAD sC, 21
 017  2DC01                 OUTPUT sC, 01[out_uart_data]
 018                        ; dump ram and restart
 018  2001A                 CALL 01A[dump_ram]
 019  22001                 JUMP 001[start]
 01A              dump_ram: 
 01A                        ; initalize counter
 01A  01D00                 LOAD sD, 00
 01B         dump_ram_loop: 
 01B                        ; print newline
 01B  01C0A                 LOAD sC, 0A
 01C  2DC01                 OUTPUT sC, 01[out_uart_data]
 01D  01C0D                 LOAD sC, 0D
 01E  2DC01                 OUTPUT sC, 01[out_uart_data]
 01F                        ; print the current address, "0x" first
 01F  01C30                 LOAD sC, 30
 020  2DC01                 OUTPUT sC, 01[out_uart_data]
 021  01C78                 LOAD sC, 78
 022  2DC01                 OUTPUT sC, 01[out_uart_data]
 023                        ; then the upper nibble first
 023  00CD0                 LOAD sC, sD
 024  14C0E                 SR0 sC
 025  14C0E                 SR0 sC
 026  14C0E                 SR0 sC
 027  14C0E                 SR0 sC
 028  20045                 CALL 045[print_hex]
 029                        ; and then the lower nibble
 029  00CD0                 LOAD sC, sD
 02A  03C0F                 AND sC, 0F[00001111'b]
 02B  20045                 CALL 045[print_hex]
 02C                        ; then a colon and a space
 02C  01C3A                 LOAD sC, 3A
 02D  2DC01                 OUTPUT sC, 01[out_uart_data]
 02E  01C20                 LOAD sC, 20
 02F  2DC01                 OUTPUT sC, 01[out_uart_data]
 030                        ; write the current address to memory interface
 030  2DD02                 OUTPUT sD, 02[out_mem_addr]
 031  01C00                 LOAD sC, 00[00000000'b]
 032  2DC02                 OUTPUT sC, 02[out_mem_addr]
 033                        ; waste a cycle
 033  11C00                 ADD sC, 00
 034                        ; grab first character
 034  09103                 INPUT s1, 03[in_mem_data]
 035  2D101                 OUTPUT s1, 01[out_uart_data]
 036                        ; grab second character
 036  09203                 INPUT s2, 03[in_mem_data]
 037  2D201                 OUTPUT s2, 01[out_uart_data]
 038                        ; wait for the output buffer to empty
 038  20041                 CALL 041[empty_tx_buf]
 039                        ; increment read address and figure out if we need to go again
 039  11D01                 ADD sD, 01
 03A  1CDF0                 COMPARE sD, sF
 03B  3A01B                 JUMP C, 01B[dump_ram_loop]
 03C                        ; print one more newline and return
 03C  01C0A                 LOAD sC, 0A
 03D  2DC01                 OUTPUT sC, 01[out_uart_data]
 03E  01C0D                 LOAD sC, 0D
 03F  2DC01                 OUTPUT sC, 01[out_uart_data]
 040  25000                 RETURN 
 041          empty_tx_buf: 
 041  09002                 INPUT s0, 02[in_uart_status]
 042  03020                 AND s0, 20[tx_data_present]
 043  36041                 JUMP NZ, 041[empty_tx_buf]
 044  25000                 RETURN 
 045             print_hex: 
 045  1DC00                 COMPARE sC, 00
 046  36049                 JUMP NZ, 049[print_hex_1]
 047  01B30                 LOAD sB, 30
 048  22082                 JUMP 082[print_hex_end]
 049           print_hex_1: 
 049  1DC01                 COMPARE sC, 01
 04A  3604D                 JUMP NZ, 04D[print_hex_2]
 04B  01B31                 LOAD sB, 31
 04C  22082                 JUMP 082[print_hex_end]
 04D           print_hex_2: 
 04D  1DC02                 COMPARE sC, 02
 04E  36051                 JUMP NZ, 051[print_hex_3]
 04F  01B32                 LOAD sB, 32
 050  22082                 JUMP 082[print_hex_end]
 051           print_hex_3: 
 051  1DC03                 COMPARE sC, 03
 052  36055                 JUMP NZ, 055[print_hex_4]
 053  01B33                 LOAD sB, 33
 054  22082                 JUMP 082[print_hex_end]
 055           print_hex_4: 
 055  1DC04                 COMPARE sC, 04
 056  36059                 JUMP NZ, 059[print_hex_5]
 057  01B34                 LOAD sB, 34
 058  22082                 JUMP 082[print_hex_end]
 059           print_hex_5: 
 059  1DC05                 COMPARE sC, 05
 05A  3605D                 JUMP NZ, 05D[print_hex_6]
 05B  01B35                 LOAD sB, 35
 05C  22082                 JUMP 082[print_hex_end]
 05D           print_hex_6: 
 05D  1DC06                 COMPARE sC, 06
 05E  36061                 JUMP NZ, 061[print_hex_7]
 05F  01B36                 LOAD sB, 36
 060  22082                 JUMP 082[print_hex_end]
 061           print_hex_7: 
 061  1DC07                 COMPARE sC, 07
 062  36065                 JUMP NZ, 065[print_hex_8]
 063  01B37                 LOAD sB, 37
 064  22082                 JUMP 082[print_hex_end]
 065           print_hex_8: 
 065  1DC08                 COMPARE sC, 08
 066  36069                 JUMP NZ, 069[print_hex_9]
 067  01B38                 LOAD sB, 38
 068  22082                 JUMP 082[print_hex_end]
 069           print_hex_9: 
 069  1DC09                 COMPARE sC, 09
 06A  3606D                 JUMP NZ, 06D[print_hex_A]
 06B  01B39                 LOAD sB, 39
 06C  22082                 JUMP 082[print_hex_end]
 06D           print_hex_A: 
 06D  1DC0A                 COMPARE sC, 0A
 06E  36071                 JUMP NZ, 071[print_hex_B]
 06F  01B41                 LOAD sB, 41
 070  22082                 JUMP 082[print_hex_end]
 071           print_hex_B: 
 071  1DC0B                 COMPARE sC, 0B
 072  36075                 JUMP NZ, 075[print_hex_C]
 073  01B42                 LOAD sB, 42
 074  22082                 JUMP 082[print_hex_end]
 075           print_hex_C: 
 075  1DC0C                 COMPARE sC, 0C
 076  36079                 JUMP NZ, 079[print_hex_D]
 077  01B43                 LOAD sB, 43
 078  22082                 JUMP 082[print_hex_end]
 079           print_hex_D: 
 079  1DC0D                 COMPARE sC, 0D
 07A  3607D                 JUMP NZ, 07D[print_hex_E]
 07B  01B44                 LOAD sB, 44
 07C  22082                 JUMP 082[print_hex_end]
 07D           print_hex_E: 
 07D  1DC0E                 COMPARE sC, 0E
 07E  36081                 JUMP NZ, 081[print_hex_F]
 07F  01B45                 LOAD sB, 45
 080  22082                 JUMP 082[print_hex_end]
 081           print_hex_F: 
 081  01B46                 LOAD sB, 46
 082         print_hex_end: 
 082  2DB01                 OUTPUT sB, 01[out_uart_data]
 083  25000                 RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\grego\Projects\fpga\picoblaze_test\picoblaze_test.srcs\programs\uart_prog.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   11'd         
 timestamp_minutes 09'd         
 timestamp_seconds 59'd         
 datestamp_year    19'd         
 datestamp_month   3'd          
 datestamp_day     13'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 out_uart_data     01           uart_prog.psm
 out_mem_addr      02           uart_prog.psm
 out_mem_data      03           uart_prog.psm
 in_uart_data      01           uart_prog.psm
 in_uart_status    02           uart_prog.psm
 in_mem_data       03           uart_prog.psm
 tx_data_present   00100000'b   uart_prog.psm
 tx_buffer_half    00010000'b   uart_prog.psm
 tx_buffer_full    00001000'b   uart_prog.psm
 rx_data_present   00000100'b   uart_prog.psm
 rx_buffer_half    00000010'b   uart_prog.psm
 rx_buffer_full    00000001'b   uart_prog.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "13 Mar 2019"  
 timestamp$        "11:09:59"     



List of line labels

   Label           Addr  Source PSM File

 * init            000   uart_prog.psm
   start           001   uart_prog.psm
   first           006   uart_prog.psm
   second          00B   uart_prog.psm
 * write           010   uart_prog.psm
   dump_ram        01A   uart_prog.psm
   dump_ram_loop   01B   uart_prog.psm
   empty_tx_buf    041   uart_prog.psm
   print_hex       045   uart_prog.psm
   print_hex_1     049   uart_prog.psm
   print_hex_2     04D   uart_prog.psm
   print_hex_3     051   uart_prog.psm
   print_hex_4     055   uart_prog.psm
   print_hex_5     059   uart_prog.psm
   print_hex_6     05D   uart_prog.psm
   print_hex_7     061   uart_prog.psm
   print_hex_8     065   uart_prog.psm
   print_hex_9     069   uart_prog.psm
   print_hex_A     06D   uart_prog.psm
   print_hex_B     071   uart_prog.psm
   print_hex_C     075   uart_prog.psm
   print_hex_D     079   uart_prog.psm
   print_hex_E     07D   uart_prog.psm
   print_hex_F     081   uart_prog.psm
   print_hex_end   082   uart_prog.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             36
 STAR              -

 AND               4
 OR                -
 XOR               -

 ADD               3
 ADDCY             -
 SUB               -
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          16
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               4
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             7
 OUTPUT           20
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             35
 JUMP@             -
 CALL              4
 CALL@             -
 RETURN            3
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
